---
title: "Data Wrangling"
author: "fabian Schroeder"
date: "April 17, 2018"
output: html_document
---

The contents of this lesson are based on the 2014 paper "Tidy Data" by Hadley Wickham from the Journal of Statistical Software. 

### Introduction

It is often said that 80% of data analysis is spent on the process of cleaning and preparing the data (Dasu and Johnson 2003). This process is often referred to as
data wrangling. It includes many steps, such as outlier checking and data imputation, reformating variables especially dates, etc. The `tidyr` package provides functions for one of these tasks: tidying: structuring datasets to facilitate analysis. 

```{r eval = TRUE}
library(tidyr)
```

The principles of tidy data provide a standard way to organize data values within a dataset.
A standard makes initial data cleaning easier because you do not need to start from scratch
and reinvent the wheel every time. The tidy data standard has been designed to facilitate
initial exploration and analysis of the data, and to simplify the development of data analysis
tools that work well together.

The paper provides a set of principles of how to structure data, that is the fundamental aproach 
for all packages in the tidyverse. We will use the `dplyr` and the `ggplot2` package which share
these common ideas.

### Tidy data

Let us first define a few terms:

A dataset is a collection of *values*, usually either numbers (if quantitative) or strings (if
qualitative). Values are organized in two ways. Every value belongs to a *variable* and an
*observation*. A variable contains all values that measure the same underlying attribute (like
height, temperature, duration) across units. An observation contains all values measured on
the same unit (like a person, or a day, or a race) across attributes.

<center>![](/home/fabian/Desktop/StatComp/figures/tidyr1.png){width=70%}</center>

Tidy data is a standard way of mapping the meaning of a dataset to its structure. A dataset is
messy or tidy depending on how rows, columns and tables are matched up with observations,
variables and types. In tidy data:

1. Each variable forms a column.
2. Each observation forms a row.
3. Each type of observational unit forms a table.

<center>![](/home/fabian/Desktop/StatComp/figures/tidyr2.png){width=50%}</center>

This table is the tidy version of the first one. Each row represents an observation, the result of one
treatment on one person, and each column is a variable.

For a given dataset, it is usually easy to figure out what are observations and what are vari-
ables, but it is surprisingly difficult to precisely define variables and observations in general.
For example, if the columns in the Table 1 were height and weight we would have been happy
to call them variables. If the columns were height and width, it would be less clear cut, as
we might think of height and width as values of a dimension variable.

Tidy data makes it easy for an analyst or a computer to extract needed variables because it
provides a standard way of structuring a dataset. Compare Table 3 to Table 1: in Table 1
you need to use different strategies to extract different variables. This slows analysis and
invites errors. If you consider how many data analysis operations involve all of the values in a
variable (every aggregation function), you can see how important it is to extract these values
in a simple, standard way. Tidy data is particularly well suited for vectorized programming
languages like R (R Core Team 2014), because the layout ensures that values of different
variables from the same observation are always paired.

### Untidy data

In order to understand the structure of tidy data better it makes sense to look at examples of untidy data.

According to Hadley Wickham the five most common problem with untidy datasets are:

* Column headers are values, not variable names.
* Multiple variables are stored in one column.
* Variables are stored in both rows and columns.
* Multiple types of observational units are stored in the same table.
* A single observational unit is stored in multiple tables.

Let us have a look at untidy data sets taken from the book R for Data Science.

```
table1

#> # A tibble: 6 × 4
#>       country  year  cases population
#>         <chr> <int>  <int>      <int>
#> 1 Afghanistan  1999    745   19987071
#> 2 Afghanistan  2000   2666   20595360
#> 3      Brazil  1999  37737  172006362
#> 4      Brazil  2000  80488  174504898
#> 5       China  1999 212258 1272915272
#> 6       China  2000 213766 1280428583

table2

#> # A tibble: 12 × 4
#>       country  year       type     count
#>         <chr> <int>      <chr>     <int>
#> 1 Afghanistan  1999      cases       745
#> 2 Afghanistan  1999 population  19987071
#> 3 Afghanistan  2000      cases      2666
#> 4 Afghanistan  2000 population  20595360
#> 5      Brazil  1999      cases     37737
#> 6      Brazil  1999 population 172006362
#> # ... with 6 more rows

table3

#> # A tibble: 6 × 3
#>       country  year              rate
#> *       <chr> <int>             <chr>
#> 1 Afghanistan  1999      745/19987071
#> 2 Afghanistan  2000     2666/20595360
#> 3      Brazil  1999   37737/172006362
#> 4      Brazil  2000   80488/174504898
#> 5       China  1999 212258/1272915272
#> 6       China  2000 213766/1280428583

# Spread across two tibbles

table4a  # cases

#> # A tibble: 3 × 3
#>       country `1999` `2000`
#> *       <chr>  <int>  <int>
#> 1 Afghanistan    745   2666
#> 2      Brazil  37737  80488
#> 3       China 212258 213766

table4b  # population

#> # A tibble: 3 × 3
#>       country     `1999`     `2000`
#> *       <chr>      <int>      <int>
#> 1 Afghanistan   19987071   20595360
#> 2      Brazil  172006362  174504898
#> 3       China 1272915272 1280428583
```
These are all representations of the same underlying data, but they are not equally easy to use. One dataset, the tidy dataset, will be much easier to work with inside the tidyverse.

### Tidying data

The first step is always to figure out what the variables and observations are. Sometimes this is easy; other times you’ll need to consult with the people who originally generated the data. The second step is to resolve one of two common problems:

* One variable might be spread across multiple columns.
* One observation might be scattered across multiple rows.

For these purposes there are two functions in tidyr: `gather()` and `spread()`. 

* Two variables might be recorded in one column
* One variable might be recorded in two columns

For these purposes there are two functions in tidyr: `separate()` and `unite()`


### `gather()' 

Gather takes multiple columns and collapses into key-value pairs, duplicating all other columns as needed. You use gather() when you notice that you have columns that are not variables.

#### Usage

```
gather(data, key = "key", value = "value", ..., na.rm = FALSE,
  convert = FALSE, factor_key = FALSE)
```

In order to understand this function one must understand the following three arguments:

`data`  A data frame.

`key`, `value`  Names of new key and value columns, as strings or symbols.  

`...` A selection of columns. If empty, all variables are selected. You can supply bare variable names, select all variables between x and z with x:z, exclude y with -y. 


Let us have a look at an example for a data set where some of the column names are not names of variables, but values of a variable (taken Example from R for Data Science)

```
table4a

#> # A tibble: 3 × 3
#>       country `1999` `2000`
#> *       <chr>  <int>  <int>
#> 1 Afghanistan    745   2666
#> 2      Brazil  37737  80488
#> 3       China 212258 213766
```
We can use gather to make the data tidy

```
table4a %>% 
  gather(`1999`, `2000`, key = "year", value = "cases")
  
#> # A tibble: 6 × 3
#>       country  year  cases
#>         <chr> <chr>  <int>
#> 1 Afghanistan  1999    745
#> 2      Brazil  1999  37737
#> 3       China  1999 212258
#> 4 Afghanistan  2000   2666
#> 5      Brazil  2000  80488
#> 6       China  2000 213766
```

<center>![](/home/fabian/Desktop/StatComp/figures/tidyr3.png)</center>

> Excercise

The layout of the following data frame stock may be accessible to the human eye, however it is not tidy according 
to the rules laid out earlier.

```{r}
library(dplyr)
# From http://stackoverflow.com/questions/1181060
stocks <- tibble(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)

```

In this example X, Y, and Z are not different variables but values of a variable called stock. How can use separate to tidy the data?

```{r }
gather(stocks, stock, price, -time)
stocks %>% gather(stock, price, -time) # the same command using the pipe operator
```

### `spread()`

Spreading is the opposite of gathering. You use it when an observation is scattered across multiple rows. 

#### Usage

```
spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE,
  sep = NULL)
```
The most important arguments are 
`data` a data frame

`key`, `value` Column names or positions.

Again, let us have a look at an example from the book R for Data Science.

```
table2
#> # A tibble: 12 × 4
#>       country  year       type     count
#>         <chr> <int>      <chr>     <int>
#> 1 Afghanistan  1999      cases       745
#> 2 Afghanistan  1999 population  19987071
#> 3 Afghanistan  2000      cases      2666
#> 4 Afghanistan  2000 population  20595360
#> 5      Brazil  1999      cases     37737
#> 6      Brazil  1999 population 172006362
#> # ... with 6 more rows

```

An observation is a country in a year, but each observation is spread across two rows.

```
spread(table2, key = type, value = count)
#> # A tibble: 6 × 4
#>       country  year  cases population
#> *       <chr> <int>  <int>      <int>
#> 1 Afghanistan  1999    745   19987071
#> 2 Afghanistan  2000   2666   20595360
#> 3      Brazil  1999  37737  172006362
#> 4      Brazil  2000  80488  174504898
#> 5       China  1999 212258 1272915272
#> 6       China  2000 213766 1280428583
```

<center>![](/home/fabian/Desktop/StatComp/figures/tidyr4.png)</center>

> Excercise

Consider the gathered stocks data from last excercise. 

```{r }
stocksm <- stocks %>% gather(stock, price, -time)
```

In our analysis we want to consider a stock an observation and the price at a given point in time is considered a variable. How can we use the `spread()` function, to create the proper formatting.

```{r }
stocksm %>% spread(time, price)
# another possibility would be to spread with key = stock
stocksm %>% spread(stock, price)
```


> Excercise C

Are `gather()` and `spread()` complementary operations?

```{r }
df1 <- data.frame(x = c("a", "b"), y = c(3, 4), z = c(5, 6))
df2 <- df1 %>% spread(x, y) %>% gather(x, y, a:b, na.rm = TRUE)
df1==df2[,c(2,3,1)]
```


### `separate()`

This function pull apart one column into multiple columns by spliiting wherever a separator character appears.

#### Usage

```
separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
  convert = FALSE, extra = "warn", fill = "warn", ...)
```
The most important arguments are
`data` the data frame

`col` the column name or position

`into` the names of the new variables to create as character vector

`sep` the separator between columns.


```
table3
#> # A tibble: 6 × 3
#>       country  year              rate
#> *       <chr> <int>             <chr>
#> 1 Afghanistan  1999      745/19987071
#> 2 Afghanistan  2000     2666/20595360
#> 3      Brazil  1999   37737/172006362
#> 4      Brazil  2000   80488/174504898
#> 5       China  1999 212258/1272915272
#> 6       China  2000 213766/1280428583
```

The rate contains both `cases` and `population` variables. We, thus, need to split it into two variables.

```
table3 %>% 
  separate(rate, into = c("cases", "population"))
#> # A tibble: 6 × 4
#>       country  year  cases population
#> *       <chr> <int>  <chr>      <chr>
#> 1 Afghanistan  1999    745   19987071
#> 2 Afghanistan  2000   2666   20595360
#> 3      Brazil  1999  37737  172006362
#> 4      Brazil  2000  80488  174504898
#> 5       China  1999 212258 1272915272
#> 6       China  2000 213766 1280428583

```

<center>![](/home/fabian/Desktop/StatComp/figures/tidyr5.png)</center>


### `unite()`

This is the inverse of `separate()`. It combines multiple columns into a single column.

#### Usage

```
separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
  convert = FALSE, extra = "warn", fill = "warn", ...)
```

Its most important arguments are

`data` the data frame

`col` the name of the new column, as a string or symbol.

`...` A selection of columns. If empty, all variables are selected. You can supply bare variable names, select all variables between x and z with x:z, exclude y with -y.

`sep` Separator to use between values.

```

table3 %>% 
  separate(year, into = c("century", "year"), sep = 2)
#> # A tibble: 6 × 4
#>       country century  year              rate
#> *       <chr>   <chr> <chr>             <chr>
#> 1 Afghanistan      19    99      745/19987071
#> 2 Afghanistan      20    00     2666/20595360
#> 3      Brazil      19    99   37737/172006362
#> 4      Brazil      20    00   80488/174504898
#> 5       China      19    99 212258/1272915272
#> 6       China      20    00 213766/1280428583

```
The century and year column can be united with the `unite()` function.

```
table5 %>% 
  unite(new, century, year)
#> # A tibble: 6 × 3
#>       country   new              rate
#> *       <chr> <chr>             <chr>
#> 1 Afghanistan 19_99      745/19987071
#> 2 Afghanistan 20_00     2666/20595360
#> 3      Brazil 19_99   37737/172006362
#> 4      Brazil 20_00   80488/174504898
#> 5       China 19_99 212258/1272915272
#> 6       China 20_00 213766/1280428583
```

<center>![](/home/fabian/Desktop/StatComp/figures/tidyr6.png)</center>





